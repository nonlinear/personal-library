# Epic v0.5.0: Smart Indexing

**Status:** üöß In Progress
**Branch:** v0.5.0
**Started:** 2026-01-25

---

## Goal

**Architecture-first approach:** Modularize to per-topic metadata, then add smart detection, then add page/chapter display.

**Why merge delta + granularity:**

- Both improve indexing (same code area: indexer.py)
- One schema upgrade for chunks.json v2.0
- Users get both improvements at once
- Modular architecture enables topic-level portability

**Phased Implementation:**

1. **Phase 1 (Architecture):** Modularize metadata.json ‚Üí per-topic `.metadata.json`
2. **Phase 2 (Target Metadata):** Add page/chapter fields to chunks.json v2.0
3. **Phase 3 (Smart Detection):** Topic-level delta detection (hash ‚Üí rebuild changed topics only)
4. **Phase 4 (Display):** Show page/chapter in research.py output

**Split from v0.4.0:**

- v0.4.0 discovered VS Code pill validation breaks with URL fragments
- Decided to split work:
  - **v0.5.0 (this epic):** Delta indexing + prepare page/chapter data
  - **v0.7.0 (future):** Display the data (solve VS Code limitation)

---

## What We're Building

**Phase 1: Modular Architecture**

```
Current (monolithic):
  books/metadata.json          ‚Üê 6000+ lines, all topics
  books/AI/policy/
    faiss.index
    chunks.json

New (distributed):
  books/metadata.json          ‚Üê registry only (topic list + config)
  books/AI/policy/
    .metadata.json             ‚Üê topic metadata
    faiss.index
    chunks.json
```

**Per-topic metadata structure:**

```json
// books/AI/policy/.metadata.json
{
  "schema_version": "2.0",
  "embedding_model": "all-MiniLM-L6-v2",
  "chunk_settings": { "size": 1024, "overlap": 200 },
  "last_indexed_at": 1737849600.0,
  "content_hash": "abc123...", // Hash of folder contents
  "books": [
    {
      "id": "book_slug",
      "title": "Book Title",
      "filename": "Book.pdf"
      // ... rest of metadata
    }
  ]
}
```

**Main metadata becomes registry:**

```json
// books/metadata.json
{
  "library_path": "/path/to/library",
  "embedding_model": "all-MiniLM-L6-v2",
  "chunk_settings": { "size": 1024, "overlap": 200 },
  "schema_version": "2.0",
  "topics": [
    { "id": "ai_policy", "path": "AI/policy" },
    { "id": "cooking", "path": "cooking" }
  ]
}
```

**Phase 2: Chunks.json schema v2.0 (Target Metadata)**

```json
{
  "chunk_full": "...",
  "book_id": "...",
  "book_title": "...",
  "filename": "Book.pdf",
  "relative_path": "AI/policy/Book.pdf",
  "page": 42, // NEW: PDF page number
  "chapter": "ch03", // NEW: EPUB chapter ID
  "cfi": "epubcfi(...)" // NEW: EPUB CFI (optional)
}
```

**Phase 3: Topic-Level Delta Detection**

```python
# Detection unit = TOPIC (not individual books)

For each topic folder:
  1. Compute content_hash (filenames + mtimes)
  2. Compare to stored hash in .metadata.json
  3. If different:
     - Delete .metadata.json, faiss.index, chunks.json
     - Rescan entire topic from filesystem
     - Rebuild vectors + metadata
  4. If same: skip entirely

Granularity: One topic at a time
Sandboxing: Failures isolated per topic
Speed: Only changed topics reindexed
```

**Benefits:**

- ‚úÖ Topic folders are portable (copy to other libraries if same embedding model)
- ‚úÖ Corruption sandboxed (corrupted topic ‚â† dead library, 53/54 topics still work)
- ‚úÖ Faster operations (small JSON files, parallel indexing possible)
- ‚úÖ Git-friendly (per-topic changes, not monolithic diffs)
- ‚úÖ Simpler validation (can we query this topic? yes/no)

---

## Session Log

### 2026-01-25: Architecture Planning

**Revised approach based on planning discussion:**

**Key decisions:**

1. **Granularity = TOPIC** (not individual books)
   - Simpler: Change in topic ‚Üí rescan entire topic
   - No complex book-level tracking needed
   - Faster, more resilient

2. **Modular metadata per topic**
   - Each topic folder = self-contained (`.metadata.json` + `faiss.index` + `chunks.json`)
   - Main `metadata.json` = registry only
   - Benefits: portable topics, sandboxed corruption, git-friendly

3. **No stable book IDs yet**
   - Filename = ID for now
   - Defer ID discussion to v0.11.0 (deduplication epic)
   - YAGNI: Don't build what we don't need yet

4. **Phased implementation:**
   - Phase 1: Modularize architecture (per-topic metadata)
   - Phase 2: Add target metadata (page/chapter to chunks)
   - Phase 3: Smart detection (topic-level delta)
   - Phase 4: Display (show page/chapter in research.py)

**Git usage clarified:**

- Git = get engine updates, NOT for sharing books
- Books are personal (potential copyright issues)
- Users share via other means (zip, etc.)
- Focus on folder-friendly architecture

**Scripts created:**

- `detect_changes.py`: Delta detection prototype (book-level, will pivot to topic-level)
- `smart_reindex.py`: CLI wrapper with --force flag

**Next actions:**

1. Implement per-topic metadata structure
2. Migrate existing monolithic metadata.json
3. Update indexer.py to use per-topic metadata
4. Update MCP server to auto-discover topics

---

## Next Steps

**Phase 1 (Architecture - Current Focus):**

1. Design per-topic `.metadata.json` structure
2. Create migration script: monolithic ‚Üí per-topic
3. Update indexer.py to write per-topic metadata
4. Update MCP server to read from per-topic metadata
5. Test with one topic folder
6. Migrate entire library

**Phase 2 (Target Metadata):**

1. Research PDF page extraction (PyPDF2, pdfplumber)
2. Research EPUB chapter/CFI extraction (ebooklib)
3. Update chunking code in indexer.py
4. Test accuracy with sample books

**Phase 3 (Smart Detection):**

1. Implement content_hash for topic folders
2. Compare hash to detect changes
3. Selective topic rebuild (nuke + rescan changed only)
4. Add --force flag for full rebuild

**Phase 4 (Display):**

1. Update research.py to show page/chapter
2. Format: "Book.pdf (page 42)"
3. No clickable links (VS Code limitation ‚Üí v0.7.0)

---

## Notes

**Key insight:** By separating data from presentation, we can make progress now while VS Code limitation is unresolved.

**Future work (v0.7.0):** Once data exists, we can explore:

- Two-link format: `[Book.pdf](path) - See page 42`
- Custom VS Code extension
- Wait for VS Code to support fragments
- Alternative display methods
