# Epic v0.5.0: Smart Indexing

**Status:** ✅ Complete
**Branch:** v0.5.0
**Started:** 2026-01-25
**Completed:** 2026-01-25

---

## Goal

**Architecture-first approach:** Modularize to per-topic metadata, then add smart detection, then add page/chapter display.

**Why merge delta + granularity:**

- Both improve indexing (same code area: indexer.py)
- One schema upgrade for chunks.json v2.0
- Users get both improvements at once
- Modular architecture enables topic-level portability

**Phased Implementation:**

1. ✅ **Phase 1 (Architecture):** Modularize metadata.json → per-topic `topic-index.json`
2. ✅ **Phase 2 (Target Metadata):** Add page/chapter fields to chunks.json v2.0
3. ✅ **Phase 3 (Smart Detection):** Topic-level delta detection (hash → rebuild changed topics only)
4. ✅ **Phase 4 (Display):** Show page/chapter in research.py output
5. ✅ **Bonus (Query Flexibility):** Add --book filter to research.py

**Split from v0.4.0:**

- v0.4.0 discovered VS Code pill validation breaks with URL fragments
- Decided to split work:
  - **v0.5.0 (this epic):** Delta indexing + prepare page/chapter data
  - **v0.7.0 (future):** Display the data (solve VS Code limitation)

---

## What We're Building

**Phase 1: Modular Architecture**

```
Current (monolithic):
  books/metadata.json          ← 6000+ lines, all topics
  books/AI/policy/
    faiss.index
    chunks.json

New (distributed):
  books/metadata.json          ← registry only (topic list + config)
  books/AI/policy/
    .metadata.json             ← topic metadata
    faiss.index
    chunks.json
```

**Per-topic metadata structure:**

```json
// books/AI/policy/.metadata.json
{
  "schema_version": "2.0",
  "embedding_model": "all-MiniLM-L6-v2",
  "chunk_settings": { "size": 1024, "overlap": 200 },
  "last_indexed_at": 1737849600.0,
  "content_hash": "abc123...", // Hash of folder contents
  "books": [
    {
      "id": "book_slug",
      "title": "Book Title",
      "filename": "Book.pdf"
      // ... rest of metadata
    }
  ]
}
```

**Main metadata becomes registry:**

```json
// books/metadata.json
{
  "library_path": "/path/to/library",
  "embedding_model": "all-MiniLM-L6-v2",
  "chunk_settings": { "size": 1024, "overlap": 200 },
  "schema_version": "2.0",
  "topics": [
    { "id": "ai_policy", "path": "AI/policy" },
    { "id": "cooking", "path": "cooking" }
  ]
}
```

**Phase 2: Chunks.json schema v2.0 (Target Metadata)**

```json
{
  "chunk_full": "...",
  "book_id": "...",
  "book_title": "...",
  "filename": "Book.pdf",
  "relative_path": "AI/policy/Book.pdf",
  "page": 42, // NEW: PDF page number
  "chapter": "ch03", // NEW: EPUB chapter ID
  "cfi": "epubcfi(...)" // NEW: EPUB CFI (optional)
}
```

**Phase 3: Topic-Level Delta Detection**

```python
# Detection unit = TOPIC (not individual books)

For each topic folder:
  1. Compute content_hash (filenames + mtimes)
  2. Compare to stored hash in .metadata.json
  3. If different:
     - Delete .metadata.json, faiss.index, chunks.json
     - Rescan entire topic from filesystem
     - Rebuild vectors + metadata
  4. If same: skip entirely

Granularity: One topic at a time
Sandboxing: Failures isolated per topic
Speed: Only changed topics reindexed
```

**Benefits:**

- ✅ Topic folders are portable (copy to other libraries if same embedding model)
- ✅ Corruption sandboxed (corrupted topic ≠ dead library, 53/54 topics still work)
- ✅ Faster operations (small JSON files, parallel indexing possible)
- ✅ Git-friendly (per-topic changes, not monolithic diffs)
- ✅ Simpler validation (can we query this topic? yes/no)

---

## Session Log

### 2026-01-25: Architecture Planning

**Revised approach based on planning discussion:**

**Key decisions:**

1. **Granularity = TOPIC** (not individual books)
   - Simpler: Change in topic → rescan entire topic
   - No complex book-level tracking needed
   - Faster, more resilient

2. **Modular metadata per topic**
   - Each topic folder = self-contained (`.metadata.json` + `faiss.index` + `chunks.json`)
   - Main `metadata.json` = registry only
   - Benefits: portable topics, sandboxed corruption, git-friendly

3. **No stable book IDs yet**
   - Filename = ID for now
   - Defer ID discussion to v0.11.0 (deduplication epic)
   - YAGNI: Don't build what we don't need yet

4. **Phased implementation:**
   - Phase 1: Modularize architecture (per-topic metadata)
   - Phase 2: Add target metadata (page/chapter to chunks)
   - Phase 3: Smart detection (topic-level delta)
   - Phase 4: Display (show page/chapter in research.py)

**Git usage clarified:**

- Git = get engine updates, NOT for sharing books
- Books are personal (potential copyright issues)
- Users share via other means (zip, etc.)
- Focus on folder-friendly architecture

**Scripts created:**

- `detect_changes.py`: Delta detection prototype (book-level, will pivot to topic-level)
- `smart_reindex.py`: CLI wrapper with --force flag

**Next actions:**

1. Implement per-topic metadata structure
2. Migrate existing monolithic metadata.json
3. Update indexer.py to use per-topic metadata
4. Update MCP server to auto-discover topics

---

## Next Steps

**Phase 1 (Architecture - Current Focus):**

1. Design per-topic `.metadata.json` structure
2. Create migration script: monolithic → per-topic
3. Update indexer.py to write per-topic metadata
4. Update MCP server to read from per-topic metadata
5. Test with one topic folder
6. Migrate entire library

**Phase 2 (Target Metadata):**

1. Research PDF page extraction (PyPDF2, pdfplumber)
2. Research EPUB chapter/CFI extraction (ebooklib)

---

## Architectural Validation

**Validated Against Our Own Library:**

Queried `management_product` topic to validate architectural decisions against change management best practices from our own books.

**Query:** `data migration strategy incremental changes backward compatibility testing validation`

**Results from "Handbook of Usability and User Experience.pdf":**

1. **Change Failure Rates** (similarity: -0.49)
   - 70-90% of change processes fail due to employee resistance
   - Root cause: Lack of trust from past failed initiatives
   - **Validation:** Our iterative approach + documentation (ARCHITECTURE.md) builds trust through transparency

2. **"Lock and Key" Model** (similarity: -0.50)
   - Intervention must adapt to context through mutual adaptation
   - NOT plug-and-play: requires staged, contextualized approach
   - Partial adoption through intermediate stages
   - **Validation:** Our phased rollout (cooking → ai_policy → all 54) allows adaptation per topic

3. **UCC Approach** (similarity: -0.51)
   - Iterative phases with continuous evaluation
   - Participatory design and trust-building
   - **Validation:** Testing small first (1 book → 4 books → 33 books) enables continuous evaluation

4. **Action Research Cycles** (similarity: -0.53)
   - Theory of constraints → identify bottlenecks iteratively
   - Evolutionary approach over linear project management
   - Developmental evaluation for emerging dynamics
   - **Validation:** Topic-level sandboxing (corrupted topic ≠ dead library) enables evolutionary deployment

5. **User Testing Evolution** (similarity: -0.54)
   - Less relevant (about unmoderated testing tools)
   - But reinforces: incremental tool improvements over big-bang redesigns

**Key Principles Confirmed:**

✅ **Iterative > Linear:** Phase 1 → 2 → 3 → 4 matches action research cycles
✅ **Evolutionary Deployment:** Topic sandboxing allows partial benefits through stages
✅ **Continuous Evaluation:** Testing progression (1 → 4 → 10 → 33 books) identifies issues early
✅ **Trust Through Transparency:** ARCHITECTURE.md + epic notes document "why" decisions made
✅ **Mutual Adaptation:** Small tests reveal needed modifications before full migration

**Conclusion:** Our architectural decisions align with established change management and UX best practices. The modular, topic-level, sandboxed approach follows proven patterns for successful system evolution. 3. Update chunking code in indexer.py 4. Test accuracy with sample books

**Phase 3 (Smart Detection):**

1. Implement content_hash for topic folders
2. Compare hash to detect changes
3. Selective topic rebuild (nuke + rescan changed only)
4. Add --force flag for full rebuild

**Phase 4 (Display):**

1. Update research.py to show page/chapter
2. Format: "Book.pdf (page 42)"
3. No clickable links (VS Code limitation → v0.7.0)

---

## Notes

**Key insight:** By separating data from presentation, we can make progress now while VS Code limitation is unresolved.

**Future work (v0.7.0):** Once data exists, we can explore:

- Two-link format: `[Book.pdf](path) - See page 42`
- Custom VS Code extension
- Wait for VS Code to support fragments
- Alternative display methods
